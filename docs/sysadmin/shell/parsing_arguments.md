---
title: "Parsing Arguments in Shell"
summary: "Creating shell scripts which can parse arguments"
date: 2021-09-19
---

There are only two methods worth considering for parsing arguments and flags in bash. Do not use
anything else, unless you know what you're doing.

# Using `getopts`

## Introduction

Unlike `getopt` provided by the
[util-linux](https://git.kernel.org/pub/scm/utils/util-linux/util-linux.git) package, `getopts` is a
bash shell built-in feature, also supported by POSIX shells. However, it's limited to POSIX/BSD
style `-a` option parsing. GNU style options like `--arg` or TCL/XF86 style options like `-arg`
don't work when using `getopts`.  If you want to support option styles besides `-a`, take a look at
[argbash](https://github.com/matejak/argbash), which is mentioned in the next section.

The basic structure when using `getopts` is

```sh
OPTIND=1
while getopts 'OPTSTRING' VARNAME; do
  case "$VARNAME" in
    "<case 1>") ... ;;
    "<case 2>") ... ;;
    ...
    \?)
      printf "%s\n" "Invalid Option! -$OPTARG" >&2
      exit 1
      ;;
    :)
      printf "%s\n" "-$OPTARG requires an argument" >&2
      exit 1
      ;;
  esac
done
shift "$((OPTIND - 1))"
```

where `'OPTSTRING'` is the list of options that you want to parse and `VARNAME` is the variable
which holds the options being processed. When using this structure, `getopts` consumes options from
`$@` by default. However, if you want to provide arguments of your own choosing, you could write

```sh
while getopts 'OPTSTRING' VARNAME "${CUSTOM_ARGS[@]}"; do
```

There are two bash built-in variables that need to be considered when using `getopts` — `OPTIND` and
`OPTARG`. `OPTIND` is meant to store the number of inputs passed to `getopts`, both options and
arguments. It starts off with a value of 1 and increases as it encounters options and arguments.
`OPTIND` is how `getopts` keeps track of the options and arguments it has to process. `OPTARG`
stores arguments and options, only if they're invalid.

We've initialized `OPTIND` to 1 and ensured that the positional parameters holding the options and
arguments have been removed (using `shift`) to make room for other functions and, possibly, other
`getopts` loops that might work on positional parameters.

## Example

Let's consider an example. I want to write a script to create a markdown file with some YAML
frontmatter for this wiki. When using [Hugo](https://gohugo.io), it provides a command, `hugo new`,
to create a new markdown file with some YAML front matter content generated by default. However,
`mkdocs` doesn't provide such a command.

I want the script to parse four options —

- `-t "TITLE"` for the title of the post
- `-s "SUMMARY"` for the summary of the post
- `-h` for the help menu
- `file path` as a mass-argument, or operand, to specify the relative path of the file to be created

The `OPTSTRING` in this case will be `:t:s:h`, where `t:` accepts the title, `s:` accepts the
summary, and `h` will print the help menu. As you may have noticed, if you want an option to accept
an argument, it should have a `:` in front of it in the `OPTSTRING`. `getopts` won't deal with
mass-arguments (the file path, in this case) so we'll ignore that for now.

The very first `:` in the `OPTSTRING` is meant to enable silent error reporting when invalid options
or arguments are specified. It's better to deal with error handling ourselves. **You may start an
`OPTSTRING` with `:` as a rule of thumb.**

Now, let's see what the code looks like.

```sh
OPTIND=1
while getopts ":t:s:h" opt; do
  case "$opt" in
    t) title="$OPTARG" ;;
    s) summary="$OPTARG" ;;
    h)
      show_help
      exit 0
      ;;
    \?)
      printf "%s\n" "Invalid Option! -$OPTARG" >&2
      exit 1
      ;;
    :)
      printf "%s\n" "-$OPTARG requires an argument" >&2
      exit 1
      ;;
  esac
done
shift "$((OPTIND - 1))"
```

If you're familiar with `while` and `case` loops, the code should be fairly self-explanatory. Since
we've disabled verbose error handling by prefixing the `OPTSTRING` with `:`, we have to handle
errors manually. If an invalid option is encountered, `getopts` assigns `?` to `opt` which is what
we've checked for in the penultimate case. If an invalid argument is encountered, `getopts` assigns
`:` to `opt` which is what we've checked for in the last case.

# Using `argbash`
